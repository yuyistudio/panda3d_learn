如何实现
=======

代码很简单，不赘述。


功能列表
=======

* 性能卓越
    1. 每隔时间n只会遍历一次树，时间n称为一个时间窗口
    2. 无特殊事件发生时，一个时间窗口内只会处理上次tick正在Running状态的节点
        1. 所以大部分时候BT的on_update相当于仅仅调用一个回调函数，几乎没有性能损失
    3. 时间窗口可以指定，一般游戏指定0.5秒应该就够用了，这意味这30帧才遍历一次BT
    4. 时间窗口的唯一作用是处理“非立即事件”。如果不需要处理此类型事件，时间窗口可以设置任意值
* 较为通用的实现，不和特定引擎或者渲染库绑定
* 支持wait功能，等待特定秒数，并在等待结束后自动设置为指定的状态
    1. 例如，NPC循环播放idle动画若干秒后，再进行其他决策，免得始终忙的团团转
* 完美支持事件
    1. 事件支持指定为立即模式，立即模式下的事件会被立即处理，无论当前处于什么状态，适合对突发事件的快速响应
    2. 事件处理支持优先级，可以由Priority指定，在BT的Action中即可处理
    3. 对于不需要及时处理的事件，即“非立即事件”，可以等到下个时间窗口进行自动处理
    4. 支持注册关注事件，对于不关注的事件将不会通知处理
    5. 支持指定特定事件为立即模式，忽略事件发布者的设置
* 支持BT级别的context
* 可以方便地结合到自己的游戏中
    1. 支持常见的CompositeNode、ActionNode、DecoratorNode
    2. 扩展新的Node类型较为容易，不同类型的游戏可能需要截然不同的新Node
    3. Action节点或者Leaf节点，支持如下回调事件，并保证在BT持续update的情况下不会丢事件，应该可以满足大部分游戏的需求：
        0. on_init()    初始化，只会调用一次
        1. on_enter()   每个迭代周期的开始被调用
        2. on_action()  每个迭代周期的过程中持续调用
        3. on_finish(is_abort, final_status)  每个迭代周期的结束被调用
    4. 游戏功能通过继承Action来实现，对可以实现的功能没有任何限制
    5. Action节点包含成员bt和parent，可以轻松访问整个BT和父节点
    6. Action可方便地使用bt提供的功能，例如获取delta_time，处理事件，发布事件，休眠等
* 支持读取JSON格式的BT配置，所以可以方便地实现BT的GUI编辑工具
    1. 自定义Node和Action也可以轻松支持JSON读取
* 文档、教程齐全，完整解释了所有可能用到的功能
    1. 开源。如果文档有任何遗漏或者描述不清，至少可以查阅源码解决问题
* Debug功能
    1. 支持打印状态转移的详情到标准输出，通过该输出可以明确知道当前BT的状态，极其方便调试，BT不再是黑盒
    2. 输出的信息非常精简，一般一个Action的生命周期内的log不超过10条，不用担心刷屏
* 不足
    1. 不支持ParallelNode。因为目前还没看到其用处，所以暂不支持
		1. 未来支持Parallel的话，更可能的方式使用多个tree来实现.要再想想。
    2. 可能还有一些Node在现有框架下难以实现，完善中
* TODO
	1. set_context的时候，如果指定了immediate模式，则会自动重新遍历tree，以确定是否要跳出当前逻辑。但是这样其实会有性能问题。待解决.
		1. 例如正在执行walk，此时修改了 target_position；那么要不要跳出当天的action呢？按理说只要context变了就需要重新遍历一遍tree；极端情况下 target_position 始终在变，此时就会每一帧都遍历tree，丧失了性能优势；如何解决呢？
		2. 一种思路是，每个bt都指定自己监听的 context 变量。如果修改的变量只有当前 action 在监听，则不需要重新遍历 tree。这种解决方案没有考虑action的优先级，优先级更低的action即使监听了某context其实也不影响当前action的继续执行。不过不考虑优先级不过容易实现。
		3. 一般的set_context如果不是立即模式，不会有这个问题。会等待下次whole-tree-tick才重新遍历tree。








